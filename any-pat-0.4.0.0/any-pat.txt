-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Quasiquoters that act on a sequence of patterns and compiles these view into patterns and expressions.
--   
--   Quasiquoters that act on a sequence of patterns and compiles these
--   view into patterns and expressions.
@package any-pat
@version 0.4.0.0


-- | The module exposes two <a>QuasiQuoter</a>s named <a>anypat</a> and
--   <a>maypat</a> that allow compiling separate patterns into a single
--   (view) pattern that will fire in case any of the patterns matches. If
--   there are any variable names, it will match these. For the
--   <a>anypat</a> it requires that all variables occur in all patterns.
--   For <a>maypat</a> that is not a requirement. For both
--   <a>QuasiQuoter</a>s, it is however required that the variables have
--   the same type in each pattern.
module Data.Pattern.Any

-- | A quasquoter to specify multiple patterns that will succeed if any of
--   the patterns match. All patterns should have the same set of variables
--   and these should have the same type, otherwise a variable would have
--   two different types, and if a variable is absent in one of the
--   patterns, the question is what to pass as value.
--   
--   <b>Examples</b>:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   example :: (Bool, a, a) -&gt; a
--   example [anypat|(False, a, _), (True, _, a)|] = a
--   </pre>
anypat :: QuasiQuoter

-- | A quasiquoter to specify multiple patterns that will succeed if any of
--   these patterns match. Patterns don't have to have the same variable
--   names but if a variable is shared over the different patterns, it
--   should have the same type. In case a variable name does not appear in
--   all patterns, it will be passed as a <a>Maybe</a> to the clause with
--   <a>Nothing</a> if a pattern matched without that variable name, and a
--   <a>Just</a> if the (first) pattern that matched had such variable.
--   
--   <b>Examples</b>:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   example :: (Bool, a) -&gt; Maybe a
--   example [maypat|(True, a), _|] = a
--   </pre>
maypat :: QuasiQuoter

-- | A <a>QuasiQuoter</a> to parse a range expression to a <a>RangeObj</a>.
--   In case the <a>QuasiQuoter</a> is used for a pattern, it compiles into
--   a <i>view pattern</i> that will work if the element is a member of the
--   <a>RangeObj</a>.
--   
--   <b>Examples</b>:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   positiveEven :: Int -&gt; Bool
--   positiveEven [rangepat|0, 2 ..|] = True
--   positiveEven _ = False
--   </pre>
rangepat :: QuasiQuoter

-- | A quasiquoter to make <a>HashMap</a> lookups more convenient. This can
--   only be used as a pattern. It takes a sequence of view patterns, where
--   it will perform the lookup on the expression part of the view pattern,
--   and match the <i>successful</i> lookup with the pattern. The
--   <a>Just</a> part is thus not used in the pattern part to indicate a
--   successful lookup. If a single variable is used, it will make a lookup
--   with a string literal with the same variable.
--   
--   <b>Examples</b>:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   sumab :: HashMap String Int -&gt; Int
--   sumab [rangepat|"a" -&gt; a, "b" -&gt; b|] = a + b
--   sumab _ = 0
--   </pre>
--   
--   This will sum up the values for `"a"` and `"b"` in the <a>HashMap</a>,
--   given these <i>both</i> exist. Otherwise, it returns `0`.
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   sumab :: HashMap String Int -&gt; Int
--   sumab [rangepat|a, b|] = a + b
--   sumab _ = 0
--   </pre>
--   
--   This will sum up the values for `"a"` and `"b"` in the <a>HashMap</a>,
--   given these <i>both</i> exist. Otherwise, it returns `0`.
hashpat :: QuasiQuoter

-- | An alias of the <a>rangepat</a> <a>QuasiQuoter</a>, this is used since
--   it looks quite similar to <tt>∊ [a .. b]</tt>, beware that the
--   <tt>ϵ</tt> in <tt>[ϵ|a .. b|]</tt> is not an <i>element of</i>
--   character, but the <i>Greek lunate epsilon</i> character which only
--   <i>looks</i> similar. The reason we use an epsiolon is because this
--   can be used as an identifier, whereas the element of is an operator.
--   
--   <b>Examples</b>:
--   
--   <pre>
--   {-# LANGUAGE ViewPatterns, QuasiQuotes #-}
--   
--   positiveEven :: Int -&gt; Bool
--   positiveEven [ϵ|2, 4 ..|] = True
--   positiveEven _ = False
--   </pre>
ϵ :: QuasiQuoter

-- | Create a view pattern that maps a HashMap with a locally scoped
--   <tt>hm</tt> parameter to a the patterns. It thus basically implicitly
--   adds <a>lookup</a> to all expressions and matches these with the given
--   patterns. The compilation fails if not all elements are view patterns.
combineHashViewPats :: NonEmpty Pat -> Q Pat

-- | Provides a list of variable names for a given <a>Pat</a>tern. The list
--   is <i>not</i> sorted. If the same variable name occurs multiple times
--   (which does not make much sense), it will be listed multiple times.
patVars :: Pat -> [Name]

-- | Provides a list of variable names for a given <a>Pat</a>tern. The list
--   is <i>not</i> sorted. If the same variable name occurs multiple times
--   (which does not make much sense), it will be listed multiple times.
patVars' :: Pat -> [Name] -> [Name]

-- | A <a>RangeObj</a> that specifies a range with a start value and
--   optionally a step value and end value.
data RangeObj a
RangeObj :: a -> Maybe a -> Maybe a -> RangeObj a
[rangeBegin] :: RangeObj a -> a
[rangeThen] :: RangeObj a -> Maybe a
[rangeEnd] :: RangeObj a -> Maybe a

-- | A <a>RangeObj</a> object that only has a start value, in Haskell
--   specified as <tt>[b ..]</tt>.
pattern FromRange :: a -> RangeObj a

-- | A <a>RangeObj</a> object that has a start value and end value, in
--   Haskell specified as <tt>[b .. e]</tt>.
pattern FromThenRange :: a -> a -> RangeObj a

-- | A <a>RangeObj</a> object with a start and next value, in Haskell
--   specified as <tt>[b, s ..]</tt>.
pattern FromToRange :: a -> a -> RangeObj a

-- | A <a>RangeObj</a> object with a start, next value and end value, in
--   Haskell specified as <tt>[b, s .. e]</tt>.
pattern FromThenToRange :: a -> a -> a -> RangeObj a

-- | Convert the <a>RangeObj</a> to a list of the values defined by the
--   range.
rangeToList :: Enum a => RangeObj a -> [a]

-- | Check if the given value is in the given <a>RangeObj</a>. This
--   function has some caveats, especially with floating points or other
--   <a>Enum</a> instances where <a>fromEnum</a> and <a>toEnum</a> are no
--   bijections. For example for floating points, `12.5` and `12.2` both
--   map on the same item, as a result, the enum will fail to work
--   properly.
inRange :: Enum a => RangeObj a -> a -> Bool

-- | Flipped alias of <a>inRange</a> that checks if an element is in range
--   of a given <a>RangeObj</a>.
(∈) :: Enum a => a -> RangeObj a -> Bool

-- | Alias of <a>inRange</a> that checks if an element is in range of a
--   given <a>RangeObj</a>.
(∋) :: Enum a => RangeObj a -> a -> Bool

-- | Determine the number of items for a <a>RangeObj</a>, given that can be
--   determined <i>easily</i>. This is only for ranges that have an
--   <i>end</i> and where the next item is different from the previous
--   (otherwise this generates an endless list).
rangeLength :: Enum a => RangeObj a -> Maybe Int

-- | Determine the direction of the range through an <a>Ordering</a>
--   object. For an increasing sequence, <a>LT</a> is used, for a sequence
--   that repeats the element, <a>Eq</a> is returned, and for a descreasing
--   sequence <a>GT</a> is used.
rangeDirection :: Ord a => RangeObj a -> Ordering

-- | Determine the last value of a <a>RangeObj</a>, given the
--   <a>RangeObj</a> has an <i>explicit</i> end value. The last value is
--   <i>not</i> per se the end value. For example for <tt>[0, 3 ..
--   10]</tt>, the last value will be <tt>9</tt>. If the <a>RangeObj</a> is
--   empty, or has no (explicit) end value, <a>Nothing</a> is returned.
rangeLastValue :: Enum a => RangeObj a -> Maybe a
instance GHC.Show.Show Data.Pattern.Any.HowPass
instance GHC.Read.Read Data.Pattern.Any.HowPass
instance GHC.Classes.Ord Data.Pattern.Any.HowPass
instance GHC.Classes.Eq Data.Pattern.Any.HowPass
instance GHC.Show.Show a => GHC.Show.Show (Data.Pattern.Any.RangeObj a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Pattern.Any.RangeObj a)
instance GHC.Base.Functor Data.Pattern.Any.RangeObj
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Pattern.Any.RangeObj a)
